(function($) {

    if (!window.Daria) { window.Daria = {}; }
    var Daria = window.Daria;

    /* ------------------------------------------------------------------------------------------------------------- */

    var DX_HAS_CREATE_DOCUMENT = true && document.implementation && document.implementation.createDocument;
    var DX_HAS_DOM_PARSER      = (typeof DOMParser !== "undefined");
    var DX_HAS_XML_SERIALIZER  = (typeof XMLSerializer !== "undefined");

    var DX_HAS_ADOPT_NODE      = (typeof document.adoptNode !== "undefined");
    Daria.DX_HAS_ADOPT_NODE = DX_HAS_ADOPT_NODE;

    var DX_HAS_IMPORT_NODE     = (typeof document.importNode !== "undefined");

    var DX_HAS_XSLT_PROCESSOR  = (typeof XSLTProcessor !== "undefined");

    var DX_HAS_XPATH_EVALUATOR = (typeof XPathEvaluator !== "undefined");

    /* ------------------------------------------------------------------------------------------------------------- */

    var DX_HAS_ACTIVE_X        = true && window.ActiveXObject;

    var DX_PID_DOM;
    var DX_PID_THREADEDDOM;
    var DX_PID_XSLTEMPLATE;

    if (DX_HAS_ACTIVE_X) {

        DX_PID_DOM         = _getPID([
        // Фееричный баг:
        // методы SelectSingleNode и SelectNodes, похоже, всегда возвращают ноды с pid'ом MSXML3,
        // даже если доступен MSXML6. В результате невозможно добавить ноды, выбранные по xpath'у в
        // основной документ.
        //  "Msxml2.DOMDocument.6.0",
            "Msxml2.DOMDocument.3.0"
        ]);
        DX_PID_THREADEDDOM = _getPID(["MSXML2.FreeThreadedDOMDocument.6.0", "MSXML2.FreeThreadedDOMDocument.3.0"]);
        DX_PID_XSLTEMPLATE = _getPID(["Msxml2.XSLTemplate.6.0", "MSXML2.XSLTemplate.3.0"]);

        // Выбираем самый свежий из доступных pid'ов
        function _getPID(pids) {
            for (var i in pids) {
                try {
                    var obj = new ActiveXObject(pids[i]);
                    delete obj;
                    return pids[i];
                } catch(e) {}
            }
        }

        function _getDomByPID(pid) {
            if (pid) {
                var doc = new ActiveXObject( pid );
                if (pid === DX_PID_DOM) {
                    doc.setProperty("SelectionLanguage", "XPath");
                    doc.setProperty("SelectionNamespaces", "xmlns:daria='http://daria.yandex.ru' xmlns:html='http://www.w3.org/1999/xhtml' xmlns='http://www.w3.org/1999/xhtml'");
                }
                return doc;
            }
        }
    }

    /* ------------------------------------------------------------------------------------------------------------- */

    if (!DX_HAS_IMPORT_NODE && DX_PID_DOM) { // Функция importNode не определена и доступен MSXML
        try {
            document.importNode = function(node, deep) {
                var name = node.nodeName;
                if (name === "#text") {
                    return document.createTextNode(node.data);
                }
                else {
                    var cName;
                    if (name === "tbody" || name === "tr") { cName = "table"; }
                    else if (name === "td") { cName = "tr"; }
                    else if (name === "option") { cName = "select"; }
                    else { cName = "div"; }

                    var container = document.createElement(cName);
                    container.innerHTML = (deep) ? node.xml : node.cloneNode(false).xml;
                    return container.firstChild;
                }
            };

            DX_HAS_IMPORT_NODE = true;

        } catch (e) { }
    }

    /* ------------------------------------------------------------------------------------------------------------- */

    // проверяем возможность создания объекта Daria.XML
    if (DX_HAS_ACTIVE_X && DX_PID_DOM ||                                                               // это IE и есть MSXML.DOM какой-то версии
        DX_HAS_CREATE_DOCUMENT && DX_HAS_DOM_PARSER && DX_HAS_XML_SERIALIZER && DX_HAS_XPATH_EVALUATOR // есть минимальные набор стандартных DOM-методов
        )
    {

        var rXML = /^</;

        Daria.XML = function() {
            this.pid = DX_PID_DOM;
            this._init.apply(this, arguments);
        }

        Daria.XML.prototype._init = function(str) {
            if (str) {
                if (typeof str === "string" && str.match(rXML)) {
                    this.loadXML(str);
                } else if (typeof str === "object") {
                    this.loadXML( json2xmlstr(str) );
                }else {
                    this.load.apply(this, arguments);
                }
            }
        }

        Daria.XML.prototype._empty = function() {
            if (DX_HAS_CREATE_DOCUMENT) {
                this.document = document.implementation.createDocument("", "", null);
            } else {
                this.document = _getDomByPID(this.pid);
            }
        }

        Daria.XML.prototype._update = function() {
            if (this.document) {
                this.nodes = this.document.documentElement;
            }
        }

        var _dx_domparser = (DX_HAS_DOM_PARSER) ? new DOMParser() : null;

        Daria.XML.prototype.loadXML = function(strXML) {
            if (DX_HAS_DOM_PARSER) {
                this.document = _dx_domparser.parseFromString(strXML, "text/xml");
            } else {
                if (!this.document) { this._empty(); }
                this.document.loadXML(strXML);
            }
            this._update();
        }

        Daria.XML.prototype._onload = function(xmlDoc) {
            this.document = xmlDoc;
            this._update();
        }

        Daria.XML.prototype.load = function(url, callback) {
            var that = this;

            var params = (typeof url !== "string") ? url : { url: url };
            var isCallback = $.isFunction(callback);

            params = $.extend({
                type: "GET",
                data: {},
                dataType: "xml",
                async: isCallback,
                success: function(xmlDoc) {
                    that._onload(xmlDoc);
                    if (isCallback) { callback.apply(that); }
                }
            }, params);

            $.ajax(params);

            return this;
        }

        Daria.XML.prototype.root = function() {
            return this.document.documentElement;
        }

        function _resolver(prefix) {
            switch (prefix) {
                case "daria": return "http://daria.yandex.ru";
                case "html": return "http://www.w3.org/1999/xhtml";
                default: return "http://www.w3.org/1999/xhtml";
            }
        }

        var _dx_xpath_evaluator = (DX_HAS_XPATH_EVALUATOR) ? new XPathEvaluator() : null;

        Daria.XML.prototype.select = function(xpath) {
            return Daria.XML.select(this.nodes, xpath);
        }

        Daria.XML.select = function(root, xpath) {
            if (DX_HAS_XPATH_EVALUATOR) {
                var result = _dx_xpath_evaluator.evaluate(xpath, root, _resolver, XPathResult.FIRST_ORDERED_NODE_TYPE, null);
                if (result) { return result.singleNodeValue; }
            } else if (DX_PID_DOM) {
                return root.selectSingleNode(xpath);
            }
        }

       if (typeof XPathResult === "undefined") {

            XPathResult = function(nodes) {
                if (nodes) {
                    this.nodes = nodes;
                    this.snapshotLength = nodes.length;

                    return this;
                }
            }

            XPathResult.prototype.snapshotItem = function(i) {
                return this.nodes[i];
            }

        }

        Daria.XML.prototype.selectNodes = function(xpath) {
            return Daria.XML.selectNodes(this.nodes, xpath);
        }

        Daria.XML.selectNodes = function(root, xpath) {
            var result;
            if (DX_HAS_XPATH_EVALUATOR) {
                result = _dx_xpath_evaluator.evaluate(xpath, root, _resolver, XPathResult.ORDERED_NODE_SNAPSHOT_TYPE, null);
            } else if (DX_PID_DOM) {
                var nodes = root.selectNodes(xpath);
                if (nodes) {
                    result = new XPathResult(nodes);
                }
            }
            if (result) {
                var a = new Array();
                for (var i = 0, l = result.snapshotLength; i < l; i++) {
                    a[i] = result.snapshotItem(i);
                }
                return a;
            }
        }

        // Для xpath'ов вида: '/folders/folder[name = ' + name + ']' -- если в name есть одинарная кавычка, то будет ошибка при вычислении xpath'а.
        // Поэтому эти кавычки эскейпятся довольно нелепым образом -- в виде concat(...).
        // foobar -> 'foobar'
        // foo'bar -> concat('foo', "'", 'bar')
        Daria.XML.escapeSingleQuote = function(s) {
            var parts = s.split("'");
            var l = parts.length;
            if (l > 1) {
                var r = "concat('";
                r += parts.join("', \"'\", '");
                r += "')";
                return r;
            } else {
                return "'" + s + "'";
            }
        }

        Daria.XML.prototype.append = function(dXML) {
            var nodes = (DX_HAS_ADOPT_NODE) ? this.document.adoptNode(dXML.nodes) : dXML.nodes;
            this.document.documentElement.appendChild(nodes);
            return this;
        }

        Daria.XML.export2html = function(nodes) {
            return document.importNode(nodes, true);
            // FIXME: Почему это закоментировано?
            /*
            if (DX_HAS_ADOPT_NODE) {
                return document.adoptNode(nodes, true);
            } else if (DX_HAS_IMPORT_NODE) {
                return document.importNode(nodes, true);
            }
            */
        }

        Daria.XML.prototype.export2html = function() {
            return Daria.XML.export2html(this.nodes);
        }

        var _dx_xmlserializer = (DX_HAS_XML_SERIALIZER) ? new XMLSerializer() : null;

        Daria.XML.prototype.toString = function() {
            return Daria.XML.xml2string(this.document);
        }

        Daria.XML.xml2string = function(node) {
            if (DX_HAS_XML_SERIALIZER) {
                return _dx_xmlserializer.serializeToString(node);
            } else {
                return node.xml;
            }
        }

    /* ------------------------------------------------------------------------------------------------------------- */

        function json2xmlstr(json, tagName) {
            var xmlStr = '';

            if (json === null) {
                return '<' + tagName + '/>';
            }

            var openTag = (tagName) ? '<' + tagName + '>' : '';
            var closeTag = (tagName) ? '</' + tagName + '>' : '';

            if (typeof json !== "object") {
                return openTag + json + closeTag;
            }

            if ($.isArray(json)) {
                $.each(json, function(i, value) {
                    xmlStr += openTag + json2xmlstr(value) + closeTag;
                });
                return xmlStr;
            }

            $.each(json, function(_tagName, _tagValue) {
                xmlStr += json2xmlstr(_tagValue, _tagName);
            });
            return openTag + xmlStr + closeTag;
        }

        Daria.XML.json2xmlstr = json2xmlstr;

        function node2json(node) {
            var json = {};
            json[node.nodeName] = _children2json(node);

            return json;
        }

        function _children2json(node) {
            var childNodes = node.childNodes;
            var childCount = childNodes.length;

            // Пустой элемент: <foo/>
            if (!childCount) {
                return null;
            }

            // Элемент с текстовым контентом: <foo>3</foo>.
            var firstChild = node.firstChild;
            if (childCount == 1 && firstChild.nodeType == 3) {
                return firstChild.nodeValue;
            }

            var childJSON = {};
            $.each(childNodes, function(i, _node) {
                if (_node.nodeType != 1) { return; } // Учитываем только элементы.
                var _name = _node.nodeName;
                var o = childJSON[_name];
                if (!o) {
                    o = childJSON[_name] = [];
                }
                o.push(_children2json(_node));
            });
            // TODO: Обработать атрибуты.

            $.each(childJSON, function(k, v) {
                if (v.length == 1) {
                    childJSON[k] = v[0];
                }
            });
            return childJSON;
        }

        Daria.XML.node2json = node2json;


    /* ------------------------------------------------------------------------------------------------------------- */

        Daria.DX_HAS_XML = true;
    }

    /* ------------------------------------------------------------------------------------------------------------- */

    if (!DX_HAS_XSLT_PROCESSOR && DX_HAS_ACTIVE_X && DX_PID_DOM && DX_PID_THREADEDDOM && DX_PID_XSLTEMPLATE) {

        XSLTProcessor = function() {
            this.template = _getDomByPID(DX_PID_XSLTEMPLATE);
            this.processor = null;
        }

        XSLTProcessor.prototype.importStylesheet = function(stylesheet) {
            this.template.stylesheet = stylesheet;
            this.processor = this.template.createProcessor();
        }

        XSLTProcessor.prototype.transformToDocument = function(input) {
            if (this.processor) {
                var output = _getDomByPID(DX_PID_DOM);
                this.processor.input = input;
                this.processor.output = output;
                this.processor.transform();
                return output;
            }
        }

        DX_HAS_XSLT_PROCESSOR = true;
    }

    /* ------------------------------------------------------------------------------------------------------------- */

    if (Daria.DX_HAS_XML && DX_HAS_XSLT_PROCESSOR) {

        Daria.XSLT = function(str, callback) {
            this.pid = DX_PID_THREADEDDOM // чтобы использовать xml-документ в качестве xsl, он должен быть типа FreeThreadedDOMDocument
            this._init(str, callback);
        }

        Daria.XSLT.prototype = new Daria.XML();

        Daria.XSLT.prototype._onload = function(xmlDoc) {
            if (xmlDoc) {
                this.document = xmlDoc;
            }
            this.processor = new XSLTProcessor();
            this.processor.importStylesheet(this.document);
        }

        if (DX_HAS_ACTIVE_X) {
            Daria.XSLT.prototype.load = function(url, callback) {
                var that = this;
                if (!this.document) { this._empty(); }
                var doc = this.document;
                var isCallback = $.isFunction(callback);
                doc.onreadystatechange = function() {
                    if (doc.readyState === 4) {
                        that._onload();
                        if (isCallback) { callback.apply(that); }
                    }
                }
                doc.resolveExternals = true; // TODO: для собранных xsl'ей (без include/import'ов и entities) эти две строчки будут не нужны
                doc.validateOnParse = false;
                doc.async = isCallback;
                doc.load(url);

                return this;
            }
        }

        Daria.XSLT.prototype.transform = function(dXML) {
            // console.dirxml(dXML.document);
            // console.log(dXML.toString());
            var out = new Daria.XML();
            // Daria.Timer.start('xslt');
            out.document = this.processor.transformToDocument(dXML.document);
            // Daria.Timer.end('xslt');
            out.nodes = out.document.documentElement;
            // console.log(out.toString());
            return out;
        }

        Daria.DX_HAS_XSLT = true;

    }

    if (!!(Daria.XML && Daria.XSLT)) {
        Daria.XOk = true;
    }


})(jQuery);

