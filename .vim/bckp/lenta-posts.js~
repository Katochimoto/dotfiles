(function(){

// Шаген из Москвы пишет:
//  Opera 9.2*, красавица неправильно выдаёт clientHeight
//  а jQuery, красавец, не использует - вообще не использует window.innerHeight
//  вот почему нам понадобилось что-то своё
var winheight = (function() {
    return (typeof window.innerHeight == "number") && function() { return window.innerHeight; } ||
        (document.compatMode == "CSS1Compat") && function() { return document.documentElement.clientHeight; } ||
        function() { return document.body.clientHeight; };
})();

var Toggler = function(onSet, onUnset){
    this.onSet = onSet || function(){};
    this.onUnset = onUnset || function(){};
};

Toggler.prototype.setVal = function (val) {
    if (this.to) {
        clearTimeout(this.to);
    }
    setTimeout(function(){
        if (this.val) {
            this.onUnset(this.val);
        }
        this.val = val;
        this.onSet(val);
    }.bind(this), 100);
};

Toggler.prototype.getVal = function () {
    return this.val;
};

Block.LentaPosts = function() {
    Block.apply(this, arguments);
}

Daria.extend(Block.LentaPosts, Block);

Block.add({
    name: "lenta-posts",
    info: {
        handlers: [ "lenta-posts", "lenta-feed", "lenta-settings", "lenta-subscriptions", "lenta-tags" ]
    },
    constructor: Block.LentaPosts
});

Block.LentaPosts.prototype.onhtmlinit = function() {
    //console.log('onhtmlinit');
    var _this = this;

    // id поста, который считается текущим по результам скрола
    this.scrolledId = null;
    // id поста, который считается текущим по результатам управения шоткатами
    this.shortcuttedId = null;

    // по мере скролинга надо помечать посты прочитанными
    Daria.events.bind('onScroll.lenta', function(evt, data){
        if (data.block && data.diff && data.block.key == _this.key) {
            // насколько я понял в случае, если мы проскролили страницу, нажали F5,
            // потом вставились посты и появилась полоса прокрутки - тригерится onScroll с diff === 0
            _this.calculateCurrent(data.diff, data.scrollTop);
        }
    });

    // при ресайзе окна
    Daria.events.bind('onResize.lenta', function(evt, data){
        if (data.block && data.block.key == _this.key) {
            _this.calculateCurrent(1);
        }
    });

    // при сворачивании/разворачивании поста
    Daria.events.bind('onPostToggle.lenta', function(evt, data){
        if (data.block && data.block.key == _this.key) {
            _this.calculateCurrent(2);
        }
    });

    // DEBUG
    this.toggler = new Toggler(
        function(id){
            $(_this.getPost(id)).css('border-left', '2px solid #EBE');
        },
        function(id){
            $(_this.getPost(id)).css('border-left', 'none')
        }
    );
    this.shorter = new Toggler(
        function(id){
            $(_this.getPost(id)).css('margin-left', '-10px');
        },
        function(id){
            $(_this.getPost(id)).css('margin-left', '0')
        }
    );
};

Block.LentaPosts.prototype.onrepaint = function(params) {
    //console.log('onrepaint');
    $('.b-lenta-message', this.getCache().node).toggleClass('b-lenta-message_open', hLentaSettings.isSet('subs_show_item'));
};

/**
 * Обработчик шотката K (вверх)
 */
Block.LentaPosts.prototype.moveCurrentUp = function () {
    var currentId = this.shortcuttedId || this.scrolledId || 0; // 0 - тут - ни о чём

    var ids = this.getIds();
    var currentIndex = $.inArray(currentId, ids);
    // если есть пост выше, то нужно проскролить до него
    if (currentIndex > 0) {
        this.shortcuttedId = ids[currentIndex - 1];
//this.shorter.setVal(this.shortcuttedId);
        var scrollTop = $(window).scrollTop();
        var coverageNext = this.getPostCoverage(this.shortcuttedId, null, scrollTop);
        if (coverageNext.top < scrollTop) {
            window.scrollTo(0, coverageNext.top);
        }
    // если выше постов уже нет, то нужно проскролить вверх экрана
    } else {
        window.scrollTo(0, 0);
        this.shortcuttedId = null;
    }
};

/**
 * Обработчик шотката (J) вниз
 */
Block.LentaPosts.prototype.moveCurrentDown = function () {
    var currentId = this.shortcuttedId || this.scrolledId || 0;

    var ids = this.getIds();
    var currentIndex = $.inArray(currentId, ids);
    // если есть пост ниже текущего, то нужно проскролить до него
    if (currentIndex > -1 && currentIndex < ids.length - 1) {
        this.shortcuttedId = ids[currentIndex + 1];
//this.shorter.setVal(this.shortcuttedId);
        var coverageNext = this.getPostCoverage(this.shortcuttedId);
        window.scrollTo(0, coverageNext.top);
    }
};

Block.LentaPosts.prototype.onshow = function(params) {
//console.log('onshow');
    var cur = hLentaPosts.getRawCacheByParams(params).data.current;
    var $button = $('.b-toolbar__item_lenta-mark-read-all', Daria.toolbar.$node);

    // FIXME
    // Скрывать кнопку при чтении тега
    // Нормально менять название кнопки
    if (cur.group_id) {
        if (cur.group_id == 'all') {
            $button.find('.b-toolbar__item__label').text('Прочитать все сообщения');
        } else {
            $button.find('.b-toolbar__item__label').text('Прочитать все сообщения в папке');
        }
    } else if (cur.feed_id) {
        $button.find('.b-toolbar__item__label').text('Прочитать все сообщения в потоке');
    } else {
        $button.find('.b-toolbar__item__label').text('Прочитать все сообщения');
    }

    // при перерисовки блока - у него новый хэндлер и нужны актуальные айдишники, а старые зануляем
    this.ids = null;
    // FIXME: как бы инициализация, нужно с нопом поговорить, как без setTimeout сделать
    setTimeout(function(){
        this.calculateCurrent(1);
    }.bind(this), 16);
};

/**
 * Возвращает копию массива с айдишниками постов текущего блока
 */
Block.LentaPosts.prototype.getIds = function() {
    if (!this.ids) {
        this.ids = hLentaPosts.getRawCacheByParams(this.params).data.ids;
    }
    return this.ids.slice();
};

/**
 * Возвращает элемент поста по id
 * @param {String} id
 * @return Element
 */
Block.LentaPosts.prototype.getPost = function (id) {
    return $('.post-' + id.replace(/\./g, '\\.'), this.getCache().node)[0];
}

/**
 * Возвращает габариты поста по id
 * @param {String} id
 * @param {Element} post пост, соответствующий этому айдишнику
 * @param {Number} scrollTop опционально можно передать текущий scrollTop, чтобы он не вычислялся в функции
 * @return  Object.top
 *          Object.height
 */
Block.LentaPosts.prototype.getPostCoverage = function (id, post, scrollTop) {

    var post = post || this.getPost(id);

    // Те броузры, которые поддерживают - пользуются getBoundingClientRect()
    // и используют в той мере, в которой могут, например IE не возвращает ширину и высоту
    var clientRect = post.getBoundingClientRect && post.getBoundingClientRect() || {}; 

    // расстояние от верха поста до верха документа
    var top = clientRect.top && (clientRect.top + (scrollTop || $(window).scrollTop())) || $(post).offset().top;
    // высота поста
    var height = clientRect.height || $(post).height();

    return {top: top, height: height};
}

/**
 * Обработчик скрола - проходится по постам до проскроленного и помечает их прочитанными, если нужно
 * @param {Number} diff на сколько и в какую сторону проскролили
 * @param {Number} scrollTop размер скрола, можно передать, если уже есть посчитанный
 */
Block.LentaPosts.prototype.calculateCurrent = function(diff, scrollTop){
//console.log('onscroll', diff);
//console.time('onscroll');
    var _this = this;

    // параметры скрола и размеры вьюпорта
    var scrollTop = scrollTop || $(window).scrollTop();
    var viewPortHeight = winheight();

    // айди постов в данном LentaPosts
    var ids = this.getIds();
    // начальный и конечный индекс отрезка массива,
    // в котором надо проверить посты на пометку
    var indexFirst = 0;
    var indexLast = ids.length - 1;

    // массив айдишников постов, которые нужно будет пометить
    var onMark = [];

    // условие пометки поста при проходе по массиву постов
    var condition;
    // модифицирует прямой for в обратный в зависимости от направления скрола
    var summand = 1;

    var posts = $('.b-lenta-message', this.getCache().node);

    // пользователь скролит вниз
    if (diff > 0) {
        // низ поста попадает во вьюпорт
        condition = function(coverage) { return coverage.top + coverage.height < scrollTop + viewPortHeight; };
        if (this.scrolledId) {
            indexFirst = $.inArray(this.scrolledId, ids);
        }
    // пользователь скролит вверх
    } else {
        // верх поста попадает во вьюпорт
        condition = function(coverage) { return coverage.top  > scrollTop; };
        summand = -1;
        indexFirst = this.scrolledId ? $.inArray(this.scrolledId, ids) : indexFirst = ids.length - 1;
        indexLast = 0;
    }

    // проверка условия помечаемости для каждого из постов
    for(var i = indexFirst; i*summand <= indexLast; i+=summand){
        var id = ids[i];
        var post = posts[i];

        var coverage = _this.getPostCoverage(id, post, scrollTop);

        if (condition(coverage)) {
            // инициализация шоткатов
            if (!this.shortcuttedId && diff > 0) {
                this.shortcuttedId = id;
            }
            // помечаться будут только раскрытые и непрочитанные посты
            if ($(post).hasClass('b-lenta-message_open') && $(post).hasClass('b-lenta-message_unread')) {
                onMark.push(id);
            }
            _this.scrolledId = id;
//this.toggler.setVal(id);
        }
        else {
            break;
        }
    };

//console.timeEnd('onscroll');
//console.log('marked:', onMark.length)
   // $.each(onMark, function(i, id){
   //     $(_this.getPost(id)).css('background-color', diff > 0 ? '#EEF' : '#FEE');
   // });
//console.time('mark');
    Actions.run("lenta-post.mark-read", {}, {ids: onMark});
//console.timeEnd('mark');
    //$(_this.getPost(_this.currentId)).css('border-left', '3px solid #CEE');
};

})();
