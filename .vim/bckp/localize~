#!/usr/bin/perl -wC

use strict;
use utf8;

use Data::Dumper;
use File::Find;

#######################################################################################################################

# Запускать так:
# $ perl -C localize

#######################################################################################################################

# TODO:
#
#   * i18n('Строка с непарными (скобками обломится', ...)
#     Если скобок не парное число, то extract_args неправильно отработает.
#   * Нет возможности указать, какие именно параметры передаются в макросы.
#   * А нужен ли AST::item? Почему бы сразу не использовать там AST::string или AST::list.
#   * Переименовать --dump в --jsdump и --xsldump.
#   * Возможность в -i и -o указать один и тот же файл.


#######################################################################################################################
#
# Классы AST и AST::* для хранения результатов парсинга и генерации js/xsl.
#
#######################################################################################################################

# Абстрактный класс, от которого наследуются классы для конкретных элементов.

package AST;

sub new {
    my ($class, $ast) = @_;

    my $self = bless {}, $class;
    $self->{ast} = $ast;

    return $self;
}

# Что это за значение. Внешние параметры нумеруются с 1 и в локализационных строках записываются как %1, %2, ...
# argn -- максимальный номер параметра, использующегося в данном ast.
# При этом, например в строке "Привет, %1 и %2" явно используются два параметра.
# Но. Если, скажем, есть строка "Привет, %some_macro", а some_macro определено как "%1 и %2", то в исходной строке argn все равно 2,
# даже несмотря на то, что эти параметры там явно и не встречаются.

# Этот метод проходит по дереву вниз и определяет, какой максимальный параметр используется в дереве.
# Само вычисление происходит в методе _calc_argn, а здесь он только вызывается и кэшируется.
sub argn {
    my ($self) = @_;

    my $argn = $self->{_argn};
    if (!$argn) {
        $argn = $self->{_argn} = $self->_calc_argn;
    }
    return $argn;
}

# Находим в ast первый попавшийся (он же и последний -- все остальные будут скалярами) ключ, значением которого является ссылка.
# И возвращаем эту ссылку, либо же ничего.
sub get_ref {
    my ($self) = @_;

    my $ast = $self->{ast};
    for (my ($k, $v) = each(%$ast)) {
        if (ref $v) { return $v; }
    }
}

# Это собственно вычисление. Этот метод может переопределяться, если нужно.
sub _calc_argn {
    my ($self) = @_;

    my $ast = $self->{ast};
    if (ref $ast eq "ARRAY") { # Для списка чего-либо, определяем максимальный argn у элементов списка.
        my $argn = 0;
        for my $item (@$ast) {
            my $argn_ = $item->_calc_argn;
            if ($argn_ > $argn) {
                $argn = $argn_;
            }
        }
        return $argn;
    } else { # Для всех остальных используем пока что хак, основанный на том, что у нас в ast максимум одно поле, ссылающееся на ast, остальное -- скаляры.
             # Так что находим первое поле в ast, для которого значение является ссылкой и вычисляем argn для него. Иначе возвращаем 0.
        my $ref = $self->get_ref;
        if ($ref) {
            return $ref->_calc_argn;
        }
        return 0;
    }
}

#######################################################################################################################

# Привет, %1
# ast = { string => new AST::string(...) }.
#
# [ письмо | письма | писем ]
# ast = { list => new AST::list(...) }
#
package AST::item;

@AST::item::ISA = ( "AST" );

sub js {
    my ($self, $state, @params) = @_;

    return $self->get_ref->js($state, @params);
}

sub xsl {
    my ($self, $state, @params) = @_;

    return $self->get_ref->xsl($state, @params);
}

sub xml {
    my ($self, $state, @params) = @_;

    return $self->get_ref->xml($state, @params);
}

#######################################################################################################################

# [ письмо | письма | писем ]
# ast = [ new AST::item(...), new AST::item(...) ] # ссылка на массив из item.
#
package AST::list;

@AST::list::ISA = ( "AST" );

sub js {
    my ($self, $state, @params) = @_;

    my $ast = $self->{ast};

    my @result = map($_->js($state, @params), @$ast);

    # Список из одного элемента отдаем просто как строку.
    if (@result > 1) {
        return "[" . join(", ", @result) . "]";
    } else {
        return $result[0];
    }
}

sub xsl {
    my ($self, $state, @params) = @_;

    my $ast = $self->{ast};

    my $prefix = $state->{prefix} || "_";
    my $i = 1;
    my $result = "";
    for my $item (@$ast) {
        my %state = %$state;
        my $prefix_ = $state{prefix} = "$prefix$i";
        $result .= qq|<xsl:with-param name="$prefix_" select="| . $item->xsl(\%state, @params) . qq|"/>|;
        $i++;
    }

    return $result;
}

#######################################################################################################################

# Привет, %1
# ast = [ # ссылка на массив, состоящий из scalar, macro, func, param.
#     new AST::scalar({ scalar => "Привет, " }),
#     new AST::param({ param => 1 })
# ]
#
package AST::string;

@AST::string::ISA = ( "AST" );

sub js {
    my ($self, $state, @params) = @_;

    my $ast = $self->{ast};
    return join(" + ", map($_->js($state, @params), @$ast)); # Каждый элемент строки преобразуем в js с помощью соответствующего метода, потом все склеиваем через " + ".
}

sub xsl {
    my ($self, $state, @params) = @_;

    my $ast = $self->{ast};
    my @result = map($_->xsl($state, @params), @$ast);

    if ($state->{as_entity}) {
        return join("", @result);
    } else {
        if (@result > 0) {
            return "concat(" . join(", ", @result) . ")";
        } else {
            return $result[0];
        }
    }
}

sub xml {
    my ($self, $state, @params) = @_;

    my $ast = $self->{ast};
    return join("", map($_->xml($state, @params), @$ast));
}

#######################################################################################################################

# %Удалено_N_писем
# ast = { macro => "Удалено_N_писем" }
#
package AST::macro;

@AST::macro::ISA = ( "AST" );

sub _calc_argn {
    my ($self) = @_;

    my $ast = $self->{ast};
    return $main::parser->argn($ast->{macro});
}

sub _get {
    my ($self) = @_;

    my $id = $self->{ast}->{macro};

    my $item = $main::parser->get_ast($id);
    if (!$item) {
        $self->_error("Не определена строка с id='$id'");
    }

    return $item;
}

sub js {
    my ($self, $state, @params) = @_;

    return $self->_get->js($state, @params);
}

sub xsl {
    my ($self, $state, @params) = @_;

    return $self->_get->xsl($state, @params);
}

#######################################################################################################################

# %if( строка | %1 )
# ast = {
#     func => "if",
#     args => new AST::list(...)
# }
#
package AST::func;

@AST::func::ISA = ( "AST" );

sub js {
    my ($self, $state, @params) = @_;

    my $ast = $self->{ast};

    my $result = "Daria.i18n[" . main::js_quote($ast->{func}) . "](";
    $result .= join(", ", map($_->js($state, @params), @{$ast->{args}->{ast}})); # Каждый аргумент преобразуем в js и все склеиваем через ", ".
    $result .= ")";

    return $result;
}

sub xsl {
    my ($self, $state, @params) = @_;

    my $ast = $self->{ast};
    my $n_call = $state->{n_call}++;
    my $result = "\$i18n-tmp-$n_call";

    my $call = qq|<xsl:variable name="i18n-tmp-$n_call"><xsl:call-template name="i18n-$ast->{func}">|;
    my $i = ord('a');
    for my $arg (@{$ast->{args}->{ast}}) {
        my $c = chr($i++);
        # Магическое условие. Если аргумент является списком или же макросом, который разворачивается в список,
        # то рисуем список как серию xsl:with-param.
        if ((ref $arg eq 'AST::list') || (ref $arg eq 'AST::macro' && ref $arg->_get eq 'AST::list')) {
            my %state = %$state;
            $state{prefix} = $c;
            $call .= $arg->xsl(\%state, @params);
        } else {
            $call .= qq|<xsl:with-param name="${c}" select="| . $arg->xsl($state, @params) . qq|"/>|;
        }
    }
    $call .= qq|</xsl:call-template></xsl:variable>|;
    push(@{$state->{calls}}, $call);

    if ($state->{as_entity}) {
        return qq|<xsl:value-of select="$result"/>|;
    } else {
        return $result;
    }
}

#######################################################################################################################

# %2
# ast = { param => 2 }
#
package AST::param;

@AST::param::ISA = ( "AST" );

# Для %n значение n и является argn.
sub _calc_argn {
    my ($self) = @_;

    return $self->{ast}->{param};
}

sub js {
    my ($self, $state, @params) = @_;

    my $param = $self->{ast}->{param};
    return "(" . $params[$param - 1] . ")";
}

sub xsl {
    my ($self, $state, @params) = @_;

    my $param = $self->{ast}->{param};
    my $result = "(" . $params[$param - 1] . ")";

    if ($state->{as_entity}) {
        return qq|<xsl:value-of select="$result"/>|;
    } else {
        return $result;
    }
}

#######################################################################################################################

# Привет
# ast = { scalar => "Пример" }
#
package AST::scalar;

@AST::scalar::ISA = ( "AST" );

sub js {
    my ($self, $state, @params) = @_;

    my $ast = $self->{ast};
    return main::js_quote($ast->{scalar});
}

sub xsl {
    my ($self, $state, @params) = @_;

    my $ast = $self->{ast};
    if ($state->{as_entity}) {
        return qq|<xsl:text>$ast->{scalar}</xsl:text>|;
    } else {
        return main::xsl_quote($ast->{scalar});
    }
}

sub xml {
    my ($self, $state, @params) = @_;

    my $ast = $self->{ast};
    return $ast->{scalar};
}

#######################################################################################################################

# <span>
# ast = { xml => "<span>" }
#
package AST::xml;

@AST::xml::ISA = ( "AST" );

sub js {
    my ($self, $state, @params) = @_;

    my $ast = $self->{ast};
    return main::js_quote($ast->{xml});
}

sub xsl {
    my ($self, $state, @params) = @_;

    my $ast = $self->{ast};
    return $ast->{xml};
}

#######################################################################################################################
#
# Основной парсер.
#
#######################################################################################################################

package Parser;

sub new {
    my ($class) = @_;

    my $self = bless {}, $class;
    $self->{_lib} = {};

    return $self;
}

#######################################################################################################################

sub get {
    my ($self, $id) = @_;

    my $item = $self->{_lib}->{$id};
    if (!$item) {
        # $self->_error("В локали $main::locale не определен id: $id.");
    }
    return $item;
}

sub get_ast {
    my ($self, $id) = @_;

    return $self->get($id)->{item};
}

sub set {
    my ($self, $id, $content) = @_;

    my $dup = $self->get($id);
    if ($dup) {
        $self->_error("Повторяющийся id: '$id'. Определен раннее в файле $dup->{filename}, в строке $dup->{lineno}.");
    }
    $self->{_lib}->{$id} = $content;
}

sub argn {
    my ($self, $id) = @_;

    return $self->get_ast($id)->argn;
}

#######################################################################################################################

# Генерим js-словарь для использования в dev-окружении.
sub js {
    my ($self, $OUT) = @_;

    if (!$main::only_json) {
        print $OUT "if (!Daria.i18n) { Daria.i18n = {}; }\n\n";
        print $OUT "Daria.i18n._dict = ";
    }

    print $OUT "{\n";
    my $lib = $self->{_lib};
    my $n = 0;
    while (my ($id, $info) = each %$lib) {
        if ($n) {
            print $OUT ",\n";
        }
        if (!$main::only_json) {
            print $OUT "    // $info->{input}\n";
        }
        print $OUT "    " . main::js_quote($id) . ": ";
        my $argn = $self->argn($id);
        my $item = $info->{item};
        if ($argn == 0) {
            print $OUT $item->js({}, $id);
        } else {
            my @args = map("_$_", 1 .. $argn);
            print $OUT "function(" . join(", ", @args) . ") {\n        return " . $item->js({}, @args) . ";\n    }";
        }
        $n++;
    }
    print $OUT "\n};\n";
}

# Генерим xsl-"словарь", чтобы проверять, что за xsl генерится.
#sub xsl {
#    my ($self, $OUT) = @_;
#
#    print $OUT <<XSL;
#<?xml version="1.0" encoding="utf-8"?>
#<xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform" version="1.0">
#
#<xsl:output encoding="utf-8" method="xml"/>
#
#<xsl:template match="/">
#XSL
#
#    my $lib = $self->{_lib};
#    my $state = {
#        n_call => 0
#    };
#    while (my ($id, $info) = each %$lib) {
#        my $item = $info->{item};
#        if (ref $item eq 'AST::list') { next; }
#
#        my $argn = $self->argn($id);
#        $state->{calls} = [];
#        print $OUT "\n    <!-- $info->{input} -->";
#        my $result = $item->xsl($state, map("_$_", 1 .. $argn));
#        my @calls = @{$state->{calls}};
#        if (@calls) {
#            print $OUT "\n    " . join("\n    ", @calls);
#        }
#        print $OUT qq|\n    <xsl:value-of select="$result"/>\n|;
#    }
#    print $OUT <<XSL;
#
#</xsl:template>
#
#</xsl:stylesheet>
#XSL
#}

#######################################################################################################################

# В $info нужно передавать ссылку на хэш вида:
#
#   {
#       lineno => 44,
#       filename => 'some.js',
#       input => 'convert( %@письмо, 34 )'
#   }
#
#   или:
#
#   {
#       filename => 'some.ru.loc'
#   }
#
sub parse {
    my ($self, $info) = @_;

    my $input = $info->{input};
    my $filename = $info->{filename};

    if (!$input) {
        if ($filename) {
            my $F;
            open($F, $filename) or $self->_sys_error("Невозможно открыть файл $filename.", "parse");
            {
                local $/;
                $input = <$F>;
            }
            close($F);
        } else {
            $self->_sys_error("Либо input, либо filename должны быть заданы.", "parse");
        }
    }

    $self->{_input} = $input;
    $self->{_filename} = $filename || "UNKNOWN";
    $self->{_lineno} = $info->{lineno} || 0;

    my @lines = split(/\n/, $input);
    for my $line (@lines) {
        $self->{_lineno}++;

        if ($line =~ /^\s*(#|$)/) { next; } # Пропускаем пустые строки и строки только с комментариями.

        $self->{_line} = $line;
        $self->{_p} = 0;
        $self->{_len} = length($line);

        my $ast = $self->line;

        # Сохраняем результат парсинга, а так же имя файла и номер строки.
        $self->set($ast->{id}, {
            item => $ast->{item},
            filename => $filename,
            lineno => $self->{_lineno},
            input => $line
        });
    }
}

#######################################################################################################################

# Грамматика:
#
#   file            ((comments | empty | line) EOL)*
#   comments        WS* '#' .*
#   empty           WS*
#   line            WS* ID WS+ item WS* comments?
#   item            list | string
#   list            '[' items ']'
#   string          (param | macro | func | char)+
#   param           '%' (INT | '{' INT '}')
#   macro           '%' (ID | '{' ID '}')
#   func            '%' ID '(' items ')'
#   args            item ('|' item)*
#   char            '\' [%#|)\]] | [^\%#|)\]]
#
#   ID              [a-zA-Zа-яА-Я_@][a-zA-Zа-яА-Я0-9_@]*
#   INT             [0-9]+
#   WS              [ \t]
#   EOL             \n

#######################################################################################################################

# Регэкспы.

#######################################################################################################################

my $DIGIT    = qr{\d};
my $ID_FIRST = qr{[a-zA-Zа-яёА-ЯЁ_@]};
my $ID_NEXT  = qr{[-a-zA-Zа-яёА-ЯЁ0-9_@]};
my $ESC_CHAR = qr{[%#|)\]]};
my $WS       = qr{[ \t]};
my $ENTITY   = qr{^(&#\d+;)}; # FIXME: Дописать сюда всякие &quot;,  &nbsp; и т.д.

#######################################################################################################################

# Методы, парсящие элементы грамматики.

#######################################################################################################################

# Локализационная строка: id и item (строка или список item'ов).
sub line {
    my ($self) = @_;

    $self->_skip_ws;

    my $id = $self->id;
    $self->ws; # Обязательный пробел.

    my $item = $self->item;

    $self->_comments; # На всякий случай, хотя в этом месте необработанных комментариев вроде быть уже не может,
                      # они все должны быть уже обработаны в item.

    if (!$self->_end) { # К этому моменту вся строка должна быть вычитана, если нет -- это ошибка.
        $self->_error("Мусор в конце строки.");
    }

    return {
        id => $id,
        item => $item,
    };
}

#######################################################################################################################

sub item {
    my ($self) = @_;

    my $cur = $self->_la;
    if ($cur eq '[') { # Либо это список item'ов.
        return  $self->list;
    } else { # Либо же строка.
        return $self->string;
    }
}

#######################################################################################################################

# Список item'ов, разделенных символом '|' и обернутый в [ ... ].
sub list {
    my ($self) = @_;

    $self->_char('[');
    $self->_skip_ws;

    my $items = $self->items;

    $self->_char(']');
    $self->_skip_ws;

    return $items;
}

#######################################################################################################################

# Список item'ов, разделенных символом '|'. Используется и в list и в списке аргументов функции.
sub items {
    my ($self) = @_;

    my $items = [ $self->item ];
    # $self->_skip_ws;

    while ($self->_la eq '|') {
        $self->_next;
        $self->_skip_ws;
        push(@$items, $self->item);
        # $self->_skip_ws;
    }

    return new AST::list($items);
}

#######################################################################################################################

# XML-тег.
sub xml {
    my ($self) = @_;

    $self->_char('<');
    my $result = '';
    my $cur;
    while ((($cur = $self->_la) ne '') && ($cur ne '>')) {
        $result .= $cur;
        $self->_next;
    }
    $self->_char('>');

    return new AST::xml({ xml => "<$result>" });
}

#######################################################################################################################

# Строка символов. Возможно с вызовами макросов и функций.
sub string {
    my ($self) = @_;

    my $string = []; # Строка разбивается в массив, состоящих из собственно строк, вызовов макросов и функций.

    my $word = ""; # Сюда собираем текущее "слово" (строку, в которой нет вызовов макросов и функций).
    my $cur;
    while (($cur = $self->_la) ne '') {
        # Концом строки является либо символ '|', разделяющий строки в списке,
        # либо одна из скобок: ']' (закрывает список) или ')' (закрывает список аргументов функции).
        # FIXME: Попробовать отказаться от использования ')', чтобы не эскейпить этот символ в обычных строках.
        if ($cur eq '|' || $cur eq ')' || $cur eq ']') { last; }

        if ($cur eq '&') { # Пытаемся найти в текущей позиции html-entity вида &#160;
            if ($self->_all =~ $ENTITY) {
                $word .= $1;
                $self->_next(length($1));
                next;
            }
        }

        if ($cur eq '\\') { # Escape-символы: '%', '#', '|', ')', ']'.
            my $next = $self->_la(1);
            if ($next =~ $ESC_CHAR) {
                $word .= $next;
                $self->_next(2);
                next;
            }
        }

        if ($cur eq '#') { # Строчные комментарии.
            $self->_comments;
            next;
        }

        if ($cur eq '%' || $cur eq '<') { # макро-подстановка или xml-тег.
            if ($word) { # Сбрасываем в string то, что уже накопилось в $word.
                push(@$string, new AST::scalar({ scalar => $word }));
                $word = "";
            }

            push(@$string, ($cur eq '%') ? $self->macro : $self->xml);
            next;
        }

        $word .= $cur; # Просто символ.
        $self->_next;
    }

    if ($word) { # Если что-то в $word еще осталось, добавляем в string.
        push(@$string, new AST::scalar({ scalar => $word }));
    }

    # Отрезаем пробелы в конце строки.
    # В списке вида 'foo | bar' у 'foo ' на конце будет лишний пробел.
    my $last = $string->[-1];
    if (ref $last eq 'AST::scalar') { # Последний элемент строки это собссно текст (scalar).
        my $s = $last->{ast}->{scalar};
        $s =~ s/\s+$//;
        if ($s) {
            $last->{ast}->{scalar} = $s;
        } else { # После отрезания ничего не осталось, так что выкидываем вообще последний элемент строки.
            pop(@$string);
        }
    }

    # NOTE: Было так.
    # return new AST::string($string);
    # А сейчас если строка состоит из одного элемента, то возвращаем просто его, а не массив из одного элемента.
    # Это упрощает AST, хотя, возможно, что-нибудь может сломаться.

    if (@$string > 1) {
        return new AST::string($string);
    } else {
        return $string->[0];
    }

}

#######################################################################################################################

# Макро вида %1 или %id или %{id}. Или вызов функции вида %func(...).
sub macro {
    my ($self) = @_;

    $self->_char('%');

    my $curly;
    if ($self->_la eq '{') { # Вариант вида %{id}. Запоминаем, что был открывающая скобка, которая потом должна быть закрыта.
        $self->_next;
        $curly = 1;
    }

    my $macro;

    if ($self->_la =~ $DIGIT) { # Вариант %1.
        $macro = new AST::param({ param => $self->int });
    } else {
        if ($self->_la !~ $ID_FIRST) { # Вот в этом месте точно должен быть id-шник.
            $self->_error("Ожидается int или id");
        }
        my $id = $self->id;

        if ($self->_la eq '(') { # Это вызов функции.
            $self->_next;
            $self->_skip_ws;

            my $items = $self->items;

            $self->_char(')');

            $macro = new AST::func({
                func => $id,
                args => $items
            });

        } else {
            $macro = new AST::macro({ macro => $id });
        }
    }

    if ($curly) { $self->_char('}'); }

    return $macro;
}

#######################################################################################################################

# id-шник.
sub id {
    my ($self) = @_;

    my $id = "";
    my $cur = $self->_la;
    if ($cur =~ $ID_FIRST) {
        $id .= $cur;
        $self->_next;
        while (($cur = $self->_la) =~ $ID_NEXT) {
            $id .= $cur;
            $self->_next;
        }
    } else {
        $self->_error("Ожидается id");
    }

    return $id;
}

# Целое число.
sub int {
    my ($self) = @_;

    my $n = "";
    my $cur;
    while (($cur = $self->_la) =~ $DIGIT) {
        $n .= $cur;
        $self->_next;
    }

    if (!$n) {
        $self->_error("Ожидается int");
    }

    return $n;
}

# Считать обязательный пробел(ы). Если пробелы необязательны, но возможны, их нужно пропускать при помощи _skip_ws().
sub ws {
    my ($self) = @_;

    if ($self->_la !~ $WS) {
        $self->_error("Ожидается пробельный символ");
    }
    $self->_skip_ws;
}

#######################################################################################################################

# Вспомогательные методы.

#######################################################################################################################

# Заглянуть вперед на k символов. По-дефолту отдается текущий символ (k = 0).
sub _la {
    my ($self, $k) = @_;
    $k = $k || 0;

    my $p = $self->{_p} + $k;
    return substr($self->{_line}, $p, 1);
}

# Вернуть все, что еще осталось в строке, начиная с текущего символа.
sub _all {
    my ($self) = @_;

    return substr($self->{_line}, $self->{_p});
}

# Есть еще символы?
sub _end {
    my ($self) = @_;

    return $self->{_p} >= $self->{_len};
}

# Перейти к следующему символу.
sub _next {
    my ($self, $k) = @_;
    $k = $k || 1;

    $self->{_p} += $k;
}

# Пропустить необязательные пробелы.
sub _skip_ws {
    my ($self) = @_;

    while ($self->_la =~ $WS) {
        $self->_next;
    }
}

sub _comments {
    my ($self) = @_;

    if ($self->_la eq '#') { # Пропускаем все до конца строки -- это строчные комментарии.
        $self->{_p} = $self->{_len};
    }
}

# Считать обязательные символ, переданный в $char. Если текущий символ не совпадает с $char -- это ошибка.
sub _char {
    my ($self, $char) = @_;

    if ($self->_la ne $char) {
        $self->_error("Ожидается символ '$char'");
    }
    $self->_next;
}

#######################################################################################################################

# Ошибки типа "Невозможно открыть файл" и т.д., не связанные с парсингом.
sub _sys_error {
    my ($self, $msg, $method) = @_;

    my $error = "ОШИБКА";
    if ($method) {
        $error .= " в методе $method";
    }
    $error .= ": " + $msg + "\n";

    die $error;
}

# Сообщение об ошибке в процессе парсинга.
sub _error {
    my ($self, $msg) = @_;

    $msg = $msg || "Неизвестная ошибка";

    my $p = $self->{_p};
    my $error = "ОШИБКА в файле $self->{_filename}, строка $self->{_lineno}, позиция $self->{_p}: $msg.\n" . "$self->{_line}\n";
    if ($p > 0) {
        $error .= "-" x $p;
    }
    $error .= "^\n"; # Показываем место ошибки в строке.

    die $error;
}






#######################################################################################################################
#
# Основная программа.
#
#######################################################################################################################

package main;

our $parser = new Parser;

use Getopt::Long;
use File::Basename;
use Cwd 'abs_path';

my $ROOT = abs_path(dirname(abs_path($0)) . "/..");

my $in;
my $out;
my $dump;
my $check;
our $locale = "ru";
our $only_json = "";
my $path = "/loc"; # Список путей, разделенных символом ':'. Например, "/loc:/blocks/loc:/handlers/loc:loc"
                   # При этом, если путь начинается с '/', то он считается от $ROOT -- т.е. от корня проекта (это .. от местоположения этого скрипта).
                   # Относительные пути считаются от места запуска.

my $options = GetOptions(
    "input=s" => \$in,
    "output=s" => \$out,
    "locale=s" => \$locale,
    "dump" => \$dump,
    "check" => \$check,
    "path=s" => \$path,
    "only-json" => \$only_json
);

if (!($options && ($check || $dump || $in))) {
    usage();
};

sub usage {
    die <<OUT;
USAGE:
    perl -C localize --check
    perl -C localize --locale en --input test.js --output test.en.js
    perl -C localize --dump --locale en --output en.js
OUT
}

#######################################################################################################################


# Зачитываем все файлы вида *.loc из всех папок, указанных в параметре path.

my %done = ();
for my $dir (split(":", $path)) {
    if (substr($dir, 0, 1) eq '/') {
        $dir = "$ROOT$dir";
    }
    $dir = abs_path($dir);

    if (-e $dir && !$done{$dir}) {
        find({ wanted => \&process, no_chdir => 1 }, $dir);
        $done{$dir} = 1;
    }
}

sub process {
    if (!/\.$locale\.loc$/) { return; }

    my $filename = $_;

    if ($check) {
        print STDERR "parsing $filename...";
    }

    $parser->parse({
        filename => $filename
    });

    if ($check) {
        print STDERR " ok\n";
    }
}

# Если была задана опция --check, то просто парсим *.loc файлы и все.
if ($check) {
    exit 0;
}

# print STDERR Data::Dumper::Dumper($parser->{_lib});
# exit 0;

######################################################################################################################

# Выбираем, куда сохранять результат. В файл или в stdout.
my $OUT;
if ($out) {
    open($OUT, ">$out") or die "ОШИБКА: Невозможно открыть файл $out на чтение.";
} else {
    $OUT = *STDOUT;
}

# Опция "Сохранить js-словарь". Для рантайм обработки.
if ($dump) {
    $parser->js($OUT);
    # $parser->xsl($OUT);
    exit 0;
}

#######################################################################################################################

my $IN;
my $content;
open($IN, $in) or die "ОШИБКА: Невозможно открыть файл $in.";
{
    local $/;
    $content = <$IN>;
}
close($IN);

#######################################################################################################################

if ($in =~ /\.js$/) { # js
    print $OUT i18n($content, {}, 'js');
} elsif ($in =~ /\.xsl$/) { # xsl
    my $state = {
        n_call => 0,
        n_id => 0
    };
    $content =~ s{(<[^>]+>)}{ i18n($1, $state, 'xsl'); }gsme;
    $state->{as_entity} = 1;
    $content =~ s{\%i18n_(.+?);}{ de_ent($1, $state, 'xsl'); }gsme;
    print $OUT $content;
} elsif ($in =~ /\.xml$/) {
    $content =~ s/&i18n_(.+?);/ $parser->get_ast($1)->xml; /gsme; # FIXME: Сделать обработку ошибок в случае, когда id не найден.
    print $OUT $content;
} else {
    # ERROR
    die "ОШИБКА: Неизвестный тип файла $in.";
}
close($OUT);

sub de_ent {
    my ($content, $state, $mode) = @_;

    if ($content =~ /^(.*?)(\((.*?)\))?$/) {
        my $id = $1;
        print STDERR "$id\n";
        my $args = $3;

        my @args = ();
        if ($args) {
            my $r = extract_args("('id', $args)");
            @args = @{ $r->{args} };
            shift @args;
        }

        return $parser->get_ast($id)->$mode($state, @args);
    }

    return ""; # NOTE: Сюда по идее попадать не должно.
}

sub i18n {
    my ($content, $state, $mode) = @_;

    my @parts = split(/i18n\(/, $content);

    $state->{calls} = [];

    my $lineno = n_cr($parts[0]) + 1;
    for (my $i = 1; $i < @parts; $i++) { # NOTE: Не обрабатываем первый part, так как в нем нет ничего интересного, он до первого i18n(...).

        my $r = extract_args($parts[$i]);
        my @args = @{ $r->{args} };
        my $left = $r->{left} || "";

        my $string = shift(@args);

        my $id = "_i18n_id" . $state->{n_id}++;
        $parser->parse({
            input => "$id $string",
            filename => $in,
            lineno => $lineno
        });
        $lineno += n_cr($parts[$i]);

        $parts[$i] = $parser->get_ast($id)->$mode($state, @args) . $left;
    }

    my $result = join("", @{$state->{calls}}) . join("", @parts);

    return $result;
}

#######################################################################################################################

# Всякие вспомогательные функции.

#######################################################################################################################

sub js_quote {
    my ($js) = @_;

    $js =~ s{'}{\\\'}gsm;
    return "'$js'";
};

sub xsl_quote {
    my ($js) = @_;

    $js =~ s{'}{&#8217;}gsm;
    $js =~ s{"}{&quot;}gsm;
    return "'$js'";
};

# На вход подаем строку вида "('%convert(%@письмо)', (n + 1))", на выходе массив, распличеный по запятым, с учетом скобок.
# Вариант -- тоже самое, но без первой скобки.
sub extract_args {
    my ($s) = @_;

    my $level = 1;
    my $p;

    # В ситуации, когда первый символ не скобка.
    if (substr($s, 0, 1) ne '(') {
        $p = 0;
    } else {
        $p = 1;
    }

    my @args = ();
    my $arg = "";
    my $len = length($s);

    while ($p < $len) {
        my $cur = substr($s, $p, 1);
        $p++;

        if ($cur eq ',' && $level == 1) { # Это запятая, разделяющая аргументы.
            push(@args, $arg);
            $arg = "";
            next;
        }

        if ($cur eq ')') {
            $level--;
            if (!$level) { last; }
        }

        $arg .= $cur;

        if ($cur eq '(') {
            $level++;
        }
    }

    if ($arg) {
        push(@args, $arg);
    }

    $args[0] =~ s/^\s*['"]//;
    $args[0] =~ s/['"]\s*//;

    for (my $i = 1; $i < @args; $i++) {
        $args[$i] =~ s/^\s*//;
        $args[$i] =~ s/\s*$//;
    }

    return {
        args => \@args,
        left => substr($s, $p)
    };
}

# Считаем количество переводов строк в тексте.
sub n_cr {
    my ($s) = @_;

    my $n = 0;
    while ($s =~ /\n/g) { $n++; }

    return $n;
}

