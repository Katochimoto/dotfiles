/*
    Daria classes:      Daria.Handler

    Global classes:     Handler
                        DoHandler
                        Request
                        RequestManager

    Global variables:   $H
*/

// ------------------------------------------------------------------------------------------------------------- //

function Handler(handler) {
    this.name = handler.name;
    this.params = handler.params || {}; // Хэш с параметрами, принимаемыми хэндлером и их дефолтными значениями (если есть).

    this._paramNames = Daria.keys(this.params).sort(); // Отсортированный массив, состоящий из имен параметров, принимаемых хэндлером.
                                                       // Нужен для построения ключей.

    this.cache = Handler._cache[this.name] = {};

    if (handler.maxage) {
        this.maxage = handler.maxage * 1000;
    }
}

var $H = Handler.handlers = {};

// ------------------------------------------------------------------------------------------------------------- //

Handler._cache = {}; // Кэши всех хэндлеров.

// ------------------------------------------------------------------------------------------------------------- //

// Строим ключ, соответствующий параметрам в params.
// Для некоторых хэндлеров построение ключа может быть переопределено.
// Например, в ../handlers/message/message.js ключом является просто id письма, что экономит время.
Handler.prototype.getKey = function(params) {
    var name = this.name;
    var that = this;

    // Строим строку вида handler=name,param1=value1,param2=value2,...,
    // выбирая имена параметров из построенного в конструкторе сортированного списка _paramNames.
    var key = "handler=" + name;
    $.each(this._paramNames, function(i, pName) {
        var pValue = params[pName];
        if (pValue && pValue !== that.params[pName]) {
            key += "," + pName + "=" + params[pName];
        }
    });

    // FIXME: Определять, что нет какого-то обязательного параметра и возвращать null в этом случае.
    if (name == 'lenta-posts') console.log(key, this.cache[key]);
    return key;
};

Handler.getKey = function(name, params) {
    return $H[name].getKey(params);
};

// ------------------------------------------------------------------------------------------------------------- //

// Вытаскиваем из переданного набора параметров те, которые принимает хэндлер.
Handler.prototype.extractParams = function(params) {
    var extracted = {};
    $.each(this._paramNames, function(i, pName) {
        var pValue = params[pName];
        if (pValue) {
            extracted[pName] = pValue;
        }
    });
    return extracted;
};

// ------------------------------------------------------------------------------------------------------------- //

// Этот метод нельзя заменять на getCache потому, что некоторые хэндлеры строят результат getCache на лету и проверка на наличие ключа в кэше дешевле.
// FIXME: Второй параметр это некий костыль. Он приходит только из одного места: из block.isCached().
//        Если есть хэндлер (из необходимых блоку), чей timestamp больше, чем timestamp блока, то блок считается невалидным.
//        Второй параметр это и есть timestamp блока. Ну то есть это время, после которого мы рассматриваем хэндлер невалидным (с точки зрения блока).
//        По-хорошему, нужно бы сделать метод хэндлера типа handler.timestamp() и сравнивать его в block.isCache().
Handler.prototype.isCached = function(key, timestamp_) {
    var cacheItem = this.cache[key];
    if (!cacheItem) { return; } // undefined означает, что кэша нет вообще никакого, а false, что есть, но уже неактуальный.

    var timestamp = cacheItem.timestamp;

    var maxage = this.maxage; // Время жизни кэша в секундах. После прошествии этого времени, кэш будет считаться невалидным.
    if (maxage) {
        var now = +new Date();
        if (now - timestamp > maxage) { return false; }
    }

    if (timestamp_) {
        return timestamp <= timestamp_;
    }

    return true;
};

// Удаляет из кэша запись с ключом key. Попутно (в теории) должен физически удалять xml-ноды из памяти.
Handler.prototype.unCache = function(key) {
    // TODO: Возможно, нужно удалять ноды при помощи removeNode.
    delete this.cache[key];
};

// Этот метод может переопределяться. Например, хэндлер messages строит на лету xml со списком писем
// из списка id-шников писем и xml-ей отдельных писем (кэшей хэндлера message). См. ../handlers/messages/messages.js
Handler.prototype.getCache = function(key) {
    var cacheItem = this.cache[key];
    if (cacheItem) {
        return cacheItem.data;
    }
};

Handler.prototype.getCacheByParams = function(params) {
    return this.getCache(this.getKey(params));
};

Handler.prototype.getRawCacheByParams = function(params) { // Метод getCache() не обязательно просто возвращает cache[key]. Например, у хэндлера ../handlers/messages/messages.js
    return this.cache[this.getKey(params)];
};

// TODO: Не очень мне нравится, что этот код не инлайном. Но вроде это совсем копейки стоит, а зато не приходится копипастить в ../handlers/messages/messages.js
Handler.prototype._setCache = function(key, data, params, timestamp, preserveTimestamp) { // Последний параметр означает "не перезаписывать timestamp, если он уже есть".

    var cacheItem = this.cache[key];
    if (!cacheItem) {
        this.cache[key] = {
            data: data,
            timestamp: timestamp,
            params: params
        };
    } else { // Если кэш уже есть, то перезаписываем только data и, если есть, timestamp (params не может измениться).
        cacheItem.data = data;
        if (timestamp && !preserveTimestamp) {
            cacheItem.timestamp = timestamp;
        }
    }
    this.onsetcache(key, data); // Возможность что-нибудь сделать с новым xml хэндлера.
};

Handler.prototype.setCache = function(key, data, params, timestamp, preserveTimestamp) {

    // FIXME: Пока что мы все равно не удаляем ноды, так что смысла нет удалять ключ, все равно он дальше перезатрется.
    // this.unCache(key); // Удаляем из кэша то, что там было.

    var item = this.cache[key];
    if (item && (item.timestamp > timestamp)) { return; }

    this._setCache(key, data, params, timestamp, preserveTimestamp);

};

// Метод вызывается при любой записи в кэш. Позволяет что-то сразу сделать с пришедшими данными.
// Например, см. ../handlers/folders/folders.js
Handler.prototype.onsetcache = function(key, data) {
    // Empty.
};

// Очищает весь кэш хэндлера.
Handler.prototype.clearCache = function(condition) {
    var that = this;
    if (condition) {
        $.each(this.cache, function(key, cacheItem) {
            if (condition(key, cacheItem)) {
                that.unCache(key);
            }
        });
    } else {
        $.each(this.cache, function(key) {
            that.unCache(key);
        });
    }
};

// ------------------------------------------------------------------------------------------------------------- //

// Выставить timestamp'ы в кэшах блока в текущее время. Нужно вызывать этот метод после ручного апдейта xml-кэшей.
Handler.prototype.touch = function(key) {
    var timestamp = +new Date();
    if (key) {
        var cacheItem = this.cache[key];
        cacheItem.timestamp = timestamp;
    } else {
        $.each(this.cache, function(key, cacheItem) {
            cacheItem.timestamp = timestamp;
        });
    }
};

// ------------------------------------------------------------------------------------------------------------- //

// Псевдо-хэндлер для модифицирующих ручек. Они никогда не кэшируются.

function DoHandler(handler) {
    Handler.call(this, handler);
}

Daria.extend(DoHandler, Handler);

DoHandler.prototype.isCached = function() {
    return false; // Нет, не закэшировано.
};

DoHandler.prototype.getCache = function() {
    // Из кэша ничего не отдаем.
};

DoHandler.prototype.setCache = function() {
    // Ничего в кэш не записываем.
};

// ------------------------------------------------------------------------------------------------------------- //

function StaticJSHandler(handler) {
    Handler.call(this, handler);
    this.jsdata = handler.data;
}

Daria.extend(StaticJSHandler, Handler);

StaticJSHandler.prototype.getCache = function() {
    if (!this.xmldata) {
        this.xmldata = (new Daria.XML(this.jsdata)).root();
    }
    return this.xmldata;
};

StaticJSHandler.prototype.isCached = function() {
    return true;
};

// ------------------------------------------------------------------------------------------------------------- //

Handler._requestKeys = function(handlers, force) {
    var requestKeys = {}; // Тут будет перечень хэндлеров и их ключей, которые действительно нужно запросить.
                          // Т.е. у них в кэше нет данных для этого набора параметров.

    $.each(handlers, function(hName, hKey) {
        var handler = $H[hName];
        if (force || !handler.isCached(hKey)) {
            requestKeys[hName] = hKey;
        }
    });

    if (Daria.isEmpty(requestKeys)) { // Все необходимые данные есть в кэше.
        return;
    }

    return requestKeys;
};

// ------------------------------------------------------------------------------------------------------------- //

// Запросить данные независимо от состояния кэшей.
Handler.doAll = function(handlers, params, callback) {
    return Handler.getAll(handlers, params, callback, { force: true });
};

// Сходить за данными, если нужно, и позвать callback.
Handler.getAll = function(handlers, params, callback, options) {

    // Если мы в handlers руками передаем список имен хэндлеров, то мы превращаем его в кэш вида { name -> key }.
    // Если же getAll вызывается из Run.start, то там сразу приходит то, что нужно.
    if ($.isArray(handlers)) {
        var _handlers = {};
        $.each(handlers, function(i, hName) {
            _handlers[hName] = $H[hName].getKey(params);
        });
        handlers = _handlers;
    }

    options = options || {};
    var requestKeys = Handler._requestKeys(handlers, options.force);

    if (!requestKeys) { // Все необходимые данные есть в кэше.
        if (callback) { callback(); } // NOTE: Было return callback(); Но вроде нигде результат callback'а не нужен. А лучше предполагать, что getAll возвращает xhr или ничего.
        return;
    }

    var request = new Request(callback, requestKeys, params, options);
    request.start();

    return request; // Возвращаем реквест, чтобы можно было остановить его в любой момент.
};

// ------------------------------------------------------------------------------------------------------------- //

// Request нужен вот для чего.
//
// Предположим, мы отправляем запрос:
// request1 = [ key1, key2 ] -> callback1 -- т.е. нужно получить данные с ключами key1, key2, а когда они все придут, позвать callback1.
// Затем хотим запросить такие данные (при этом первый запрос может быть еще не вернулся):
// request2 = [ key1, key2, key3 ] -> callback2. Но запрос за key1, key2 уже отправлен, так что на самом деле нужно послать запрос
// request2' = [ key3 ], но callback2 нужно звать только тогда, когда придут оба ответа.
//
// Т.е. в каждый момент каждый ключ запрошен не более одного раза. И как только для какого-то запроса все ключи пришли,
// будет вызван соответствующий callback.
//
// Это позволяет не париться по поводу, а запрошены ли такие-то данные уже. Просто всегда запрашиваем то, что нам нужно.
// Если данные уже в кэше, никаких запросов не будет. Если часть (или все данные) уже запрошены, но ответ еще не пришел,
// значит будет запрошено только то, что еще не было запрошено.

var Request = Handler.Request = function(callback, requestKeys, params, options) {
    this.callback = callback;
    this.requestKeys = requestKeys; // Хэш вида { name -> key }. name -- имя хэндлера, key -- ключ этого хэндлера для набора параметров params.
    this.params = $.extend({}, params); // Поскольку мы будем "портить" params параметрами для гвардов, то просто делаем копию.
    this.options = options || {};

    this.id = Request._id++; // Уникальный id запроса.
    this.empty = true; // Нет реально запрошенных ключей. Если таки будут запрошены ключи, то this.empty будет выставлено в false.
    this.keys = {}; // По сути тут будет Daria.array2obj( Daria.values(requestKeys) ).

    this.errors = {}; // Ошибки, найденные в ответах хэндлеров.

    this._addKeys(requestKeys);
};

Request._id = 1;
Request._requestedKeys = {}; // Хэш вида { key -> request-id }. Храним запрошенные ключи, значением является минимальный id реквеста, который засчитается за ответ.

// Добавляем список ключей к запросу.
Request.prototype._addKeys = function(_keys) {

    var id      = this.id;
    var force   = this.options.force;
    var keys    = this.keys;
    var params  = this.params;
    var requestedKeys = Request._requestedKeys;

    var that = this;

    $.each(_keys, function(name, key) {
        var requested = requestedKeys[key];
        if (force || !requested) { // За этим ключом еще не было запроса. Или же мы форсируем запрос.
            if (!requested) {
                requested = requestedKeys[key] = {
                    requests: []
                };
            }
            requested.id = id; // В глобальном хранилище запрошенных ключей помечаем, что этот ключ нужно ждать от минимум этого request-id.
                               // При этом, если вдруг придет ответ с этим же ключом, но с request-id меньше, чем мы тут сохранили,
                               // то этот ответ будет проигнорирован.

            params['handler.' + name] = 1; // Добавляем параметр для гварда.
            that.empty = false; // Запрос не "пустой", то есть будет реальный ajax-запрос (альтернатива -- все ключи уже были запрошены ранее и еще не пришли,
                                // так что запрос "пустой", он сам ничего не запрашивает, а просто ждет предыдущих ответов).
        }
        keys[key] = 1;
        requested.requests.push(that); // Запоминаем, что этот реквест ожидает ключ key.
    });

    // В итоге у нас:
    // 1. На выходе есть хэш keys, в котором в качестве ключей все добавленные ключи хэндлеров,
    // 2. В requestedKeys[key].requests есть ссылка на этот реквест; когда придет ответ с этим ключом, мы сможем пройтись по всем реквестам, ожидающим его.
    // 3. В params добавлены параметры для гвардов для тех ключей, которые еще не запрошены.
    // 4. Если запрос не "пустой", то свойство empty == false.

};

Request.prototype.done = function(data) {

    var id = this.id;
    var requestedKeys = Request._requestedKeys;

    $.each(this.keys, function(key) {

        var requested = requestedKeys[key];
        if (!requested || requested.id > id) { return; } // Либо мы уже не ждем этот ключ (он пришел раньше),
                                                         // либо же этот ответ недостаточно свежий и мы будет ждать более актуальный ответ.

        // NOTE: Важно сперва удалить ключ, а потом уже делать doneKey. Потому что если в callback'е, вызываемом из doneKey снова инициируется
        //       новый реквест, то в них все еще считается, что мы ждем каких ключей.
        delete requestedKeys[key]; // Все. Ключ пришел, больше мы его не ждем.

        $.each(requested.requests, function(i, request) {
            request.doneKey(key, data); // Говорим реквесту, что пришел ключ key.
        });
    });

};

Request.prototype.doneKey = function(key, data) {
    var keys = this.keys;
    delete keys[key];

    if (Daria.isEmpty(keys)) { // Если это был последний ключ, то все -- запрос выполнен.
        if (this.callback) {
            this.callback(data);
        }
    }
};

// Пока что тут всего лишь выключаем loader. Запрос все равно вернется рано или поздно и done() случится именно тогда.
Request.prototype.stop = function(key) {
    if (this.loader) {
        this.loader.stop();
    }
};

Request.prototype.start = function() {

    if (this.empty) { return; }

    var options = this.options;
    this.loader = new Daria.Loader(options.loader); // Если в Loader передать null, то вернется "пустой" лоадер, который ничего не делает.
                                                         // Если передать false (undefined), то вернется дефолтный лоадер, анимирующий меню.
                                                         // Еще можно передать объект с двумя методами start() и stop(), тогда он и вернется.
    this.loader.start(); // Включаем "Загружается...".

    var id = this.id;

    var that = this;
    var requestKeys = this.requestKeys;
    var params = this.params;

    if (options.force) { // В do-запросы добавляем ключ для подписи. Он приходит в каждом ответе handlers.xml.
                         // Первый запрос у нас всегда не do-, так что ключ у нас будет всегда, когда он уже нужен.
        $.extend(params, Page.doParams);
    }

    this.xhr = $.ajax({
        url: "handlers/handlers.xml",
        type: "post",
        data: this.params,
        success: function(xml, status) {
            // Ответ приходит в виде:
            //  <handlers>
            //      <handler name="messages">
            //          <messages>
            //          ...
            //          </messages>
            //      </handler>
            //      ...
            //  </handlers>
            //

            //
            // if (status != 'success') {
            //     // do something.
            // }

            if (xml) { // NOTE: Тут, кажется, бага в jquery -- если интернет был отключен и мы пытаемся сделать запрос,
                       //       то вызывается не error, а таки success.
                if (Daria.XML.select(xml, "/handlers/handler/auther[error]")) { // В ответе сказано, что мы незалогинены.
                    Daria.doLogin(); // Идем логиниться.
                } else {
                    var timestamp = +new Date(); // FIXME: Здесь надо бы использовать не timestamp, а ревизию ящика.

                    var nodes = Daria.XML.selectNodes(xml, "/handlers/handler"); // Разбираем ответ. Каждый хэндлер должен вытащить из него свой кусок и сохранить в кэш.
                    $.each(nodes, function(i, root) {
                        var name = root.getAttribute("name"); // Имя хэндлера приходит в атрибуте name.

                        var error = Daria.XML.select(root, "//error");
                        if (error) {
                            that.errors[name] = {
                                code: error.getAttribute("code"),
                                'enum': error.getAttribute("enum"),
                                reason: error.getAttribute("reason"),
                                hash: error.getAttribute("hash")
                            };
                            Daria.ErrorLog.send($.extend({errorType: "HandlerError", name: name}, that.errors[name])); // Логируем ошибку
                            return;
                        }

                        var node = root.getElementsByTagName(name)[0]; // Контент ответа приходит в теге с именем, совпадающим с именем хэндлера.
                        if (node) {
                            var key = requestKeys[name];
                            $H[name].setCache(key, node, params, timestamp); // Вытаскиваем из тега <handler> его контент по имени блока и сохраняем в кэше.
                        }
                    });

                }
            }

            that.loader.stop(); // Выключаем "Загружается...".
            that.done(xml); // Завершаем запрос.
        },
        error: function() { // FIXME: Кажется, даже если отключить интернет, все равно сюда не попадает, а попадает почему-то в success. Но пусть побудет.
            that.loader.stop(); // Выключаем "Загружается...".
            that.done(null); // Завершаем запрос.
        }
    });
};

// ------------------------------------------------------------------------------------------------------------- //

Handler._pagesXML = []; // FIXME: Заляпа. Чтобы xml-документы не протухали, храним ссылки на них.

Handler._buildXML = function(handlers, keys, json) {

    if (typeof json != "object") { // В json или готовый объект для преобразования в xml, или же строка с названием корневого тега.
        var tag = json || "page";
        json = {};
        json[tag] = null;
    }
    var xml = new Daria.XML(json);
    var root = xml.root();

    Handler._pagesXML.push(xml); // FIXME: Заляпа!

    $.each(handlers, function(i, hName) {
        var hKey = keys[i];
        var handler = $H[hName];
        var hXml = handler.getCache(hKey);
        if (hXml) {
            // TODO: Нормальную проверку на adoptNode.
            try {
                root.appendChild(xml.document.adoptNode(hXml));
            } catch (e) {
                root.appendChild(hXml);
            }
        }
    });

    return xml;
};

// buildXML([ 'message', 'messages' ], { id: 1, current_folder: 2 });
// buildXML([ 'message', 'message', 'messages' ], [ { id: 1 }, { id: 2 }, { current_folder: 2 } ]);
// buildXML([ 'message', 'message', 'messages' ], [ 'handler=message,id=1', { id: 2 }, 'handler=messages,current_folder=2' ]);

Handler.buildXML = function(handlers, params, json) {

    var keys = [];
    if ($.isArray(params)) {
        $.each(handlers, function(i, hName) {
            var hKey = params[i];
            keys[i] = (typeof hKey == "string") ? hKey : Handler.getKey(hName, hKey);
        });
    } else {
        $.each(handlers, function(i, hName) {
            keys[i] = Handler.getKey(hName, params);
        });
    }

    return Handler._buildXML(handlers, keys, json);
};

// ------------------------------------------------------------------------------------------------------------- //

Daria.Handler = Handler;
Daria.DoHandler = DoHandler;

// ------------------------------------------------------------------------------------------------------------- //

